// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Check for compatibility between `uniffi` and `uniffi_bindgen` versions.
// Note that we have an error message on the same line as the assertion.
// This is important, because if the assertion fails, the compiler only
// seems to show that single line as context for the user.
uniffi::assert_compatible_version!("0.17.0"); // Please check that you depend on version 0.17.0 of the `uniffi` crate.

// Everybody gets basic buffer support, since it's needed for passing complex types over the FFI.

/// This helper allocates a new byte buffer owned by the Rust code, and returns it
/// to the foreign-language code as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_ots_1904_rustbuffer_alloc(
    size: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        uniffi::RustBuffer::new_with_size(size.max(0) as usize)
    })
}

/// This helper copies bytes owned by the foreign-language code into a new byte buffer owned
/// by the Rust code, and returns it as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
///
/// # Safety
/// This function will dereference a provided pointer in order to copy bytes from it, so
/// make sure the `ForeignBytes` struct contains a valid pointer and length.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_ots_1904_rustbuffer_from_bytes(
    bytes: uniffi::ForeignBytes,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        let bytes = bytes.as_slice();
        uniffi::RustBuffer::from_vec(bytes.to_vec())
    })
}

/// Free a byte buffer that had previously been passed to the foreign language code.
///
/// # Safety
/// The argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_ots_1904_rustbuffer_free(
    buf: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::call_with_output(call_status, || uniffi::RustBuffer::destroy(buf))
}

/// Reserve additional capacity in a byte buffer that had previously been passed to the
/// foreign language code.
///
/// The first argument *must* be a uniquely-owned `RustBuffer` previously
/// obtained from a call into the Rust code that returned a buffer. Its underlying data pointer
/// will be reallocated if necessary and returned in a new `RustBuffer` struct.
///
/// The second argument must be the minimum number of *additional* bytes to reserve
/// capacity for in the buffer; it is likely to reserve additional capacity in practice
/// due to amortized growth strategy of Rust vectors.
///
/// # Safety
/// The first argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_ots_1904_rustbuffer_reserve(
    buf: uniffi::RustBuffer,
    additional: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        use std::convert::TryInto;
        let additional: usize = additional
            .try_into()
            .expect("additional buffer length negative or overflowed");
        let mut v = buf.destroy_into_vec();
        v.reserve(additional);
        uniffi::RustBuffer::from_vec(v)
    })
}

// Error definitions, corresponding to `error` in the UDL.

#[doc(hidden)]
pub struct FfiConverterTypeError;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeError {
    type RustType = Error;

    // For "flat" error enums, we stringify the error on the Rust side and surface that
    // as the error message in the foreign language.

    fn write(obj: Error, buf: &mut std::vec::Vec<u8>) {
        use uniffi::deps::bytes::BufMut;
        let msg = obj.to_string();
        match obj {
            Error::NetworkError { .. } => {
                buf.put_i32(1);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            Error::InvalidOts { .. } => {
                buf.put_i32(2);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            Error::IOError { .. } => {
                buf.put_i32(3);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            Error::InvalidFile { .. } => {
                buf.put_i32(4);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            Error::BitcoinNodeError { .. } => {
                buf.put_i32(5);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
            Error::Generic { .. } => {
                buf.put_i32(6);
                <String as uniffi::FfiConverter>::write(msg, buf);
            }
        };
    }

    fn try_read(_buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<Error> {
        // It's not currently possible to send errors from the foreign language *into* Rust.
        panic!("try_read not supported for flat errors");
    }
}

impl uniffi::FfiError for FfiConverterTypeError {}

// Enum defitions, corresponding to `enum` in UDL.

#[doc(hidden)]
pub struct FfiConverterTypeDigestType;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeDigestType {
    type RustType = DigestType;

    fn write(obj: Self::RustType, buf: &mut std::vec::Vec<u8>) {
        use uniffi::deps::bytes::BufMut;
        match obj {
            DigestType::Sha1 {} => {
                buf.put_i32(1);
            }
            DigestType::Sha256 {} => {
                buf.put_i32(2);
            }
            DigestType::Ripemd160 {} => {
                buf.put_i32(3);
            }
        };
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<DigestType> {
        use uniffi::deps::bytes::Buf;
        uniffi::check_remaining(buf, 4)?;
        Ok(match buf.get_i32() {
            1 => DigestType::Sha1,
            2 => DigestType::Sha256,
            3 => DigestType::Ripemd160,
            v => uniffi::deps::anyhow::bail!("Invalid DigestType enum value: {}", v),
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeOp;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeOp {
    type RustType = Op;

    fn write(obj: Self::RustType, buf: &mut std::vec::Vec<u8>) {
        use uniffi::deps::bytes::BufMut;
        match obj {
            Op::Sha1 {} => {
                buf.put_i32(1);
            }
            Op::Sha256 {} => {
                buf.put_i32(2);
            }
            Op::Ripemd160 {} => {
                buf.put_i32(3);
            }
            Op::Hexlify {} => {
                buf.put_i32(4);
            }
            Op::Reverse {} => {
                buf.put_i32(5);
            }
            Op::Append { data } => {
                buf.put_i32(6);
                <std::vec::Vec<u8> as uniffi::FfiConverter>::write(data, buf);
            }
            Op::Prepend { data } => {
                buf.put_i32(7);
                <std::vec::Vec<u8> as uniffi::FfiConverter>::write(data, buf);
            }
        };
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<Op> {
        use uniffi::deps::bytes::Buf;
        uniffi::check_remaining(buf, 4)?;
        Ok(match buf.get_i32() {
            1 => Op::Sha1,
            2 => Op::Sha256,
            3 => Op::Ripemd160,
            4 => Op::Hexlify,
            5 => Op::Reverse,
            6 => Op::Append {
                data: <std::vec::Vec<u8> as uniffi::FfiConverter>::try_read(buf)?,
            },
            7 => Op::Prepend {
                data: <std::vec::Vec<u8> as uniffi::FfiConverter>::try_read(buf)?,
            },
            v => uniffi::deps::anyhow::bail!("Invalid Op enum value: {}", v),
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeAttestation;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeAttestation {
    type RustType = Attestation;

    fn write(obj: Self::RustType, buf: &mut std::vec::Vec<u8>) {
        use uniffi::deps::bytes::BufMut;
        match obj {
            Attestation::Bitcoin { height } => {
                buf.put_i32(1);
                <u8 as uniffi::FfiConverter>::write(height, buf);
            }
            Attestation::Pending { uri } => {
                buf.put_i32(2);
                <String as uniffi::FfiConverter>::write(uri, buf);
            }
            Attestation::Unknown { tag, data } => {
                buf.put_i32(3);
                <std::vec::Vec<u8> as uniffi::FfiConverter>::write(tag, buf);
                <std::vec::Vec<u8> as uniffi::FfiConverter>::write(data, buf);
            }
        };
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<Attestation> {
        use uniffi::deps::bytes::Buf;
        uniffi::check_remaining(buf, 4)?;
        Ok(match buf.get_i32() {
            1 => Attestation::Bitcoin {
                height: <u8 as uniffi::FfiConverter>::try_read(buf)?,
            },
            2 => Attestation::Pending {
                uri: <String as uniffi::FfiConverter>::try_read(buf)?,
            },
            3 => Attestation::Unknown {
                tag: <std::vec::Vec<u8> as uniffi::FfiConverter>::try_read(buf)?,
                data: <std::vec::Vec<u8> as uniffi::FfiConverter>::try_read(buf)?,
            },
            v => uniffi::deps::anyhow::bail!("Invalid Attestation enum value: {}", v),
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeStepData;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStepData {
    type RustType = StepData;

    fn write(obj: Self::RustType, buf: &mut std::vec::Vec<u8>) {
        use uniffi::deps::bytes::BufMut;
        match obj {
            StepData::fork {} => {
                buf.put_i32(1);
            }
            StepData::op { operation } => {
                buf.put_i32(2);
                <FfiConverterTypeOp as uniffi::FfiConverter>::write(operation, buf);
            }
            StepData::attestation { attestation } => {
                buf.put_i32(3);
                <FfiConverterTypeAttestation as uniffi::FfiConverter>::write(attestation, buf);
            }
        };
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<StepData> {
        use uniffi::deps::bytes::Buf;
        uniffi::check_remaining(buf, 4)?;
        Ok(match buf.get_i32() {
            1 => StepData::fork,
            2 => StepData::op {
                operation: <FfiConverterTypeOp as uniffi::FfiConverter>::try_read(buf)?,
            },
            3 => StepData::attestation {
                attestation: <FfiConverterTypeAttestation as uniffi::FfiConverter>::try_read(buf)?,
            },
            v => uniffi::deps::anyhow::bail!("Invalid StepData enum value: {}", v),
        })
    }
}

// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.

#[doc(hidden)]
pub struct FfiConverterTypeStep;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeStep {
    type RustType = Step;

    fn write(obj: Step, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <FfiConverterTypeStepData as uniffi::FfiConverter>::write(obj.data, buf);
        <std::vec::Vec<u8> as uniffi::FfiConverter>::write(obj.output, buf);
        <std::vec::Vec<FfiConverterTypeStep> as uniffi::FfiConverter>::write(obj.next, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<Step> {
        Ok(Step {
            data: <FfiConverterTypeStepData as uniffi::FfiConverter>::try_read(buf)?,
            output: <std::vec::Vec<u8> as uniffi::FfiConverter>::try_read(buf)?,
            next: <std::vec::Vec<FfiConverterTypeStep> as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeTimestamp;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeTimestamp {
    type RustType = Timestamp;

    fn write(obj: Timestamp, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <std::vec::Vec<u8> as uniffi::FfiConverter>::write(obj.start_digest, buf);
        <FfiConverterTypeStep as uniffi::FfiConverter>::write(obj.first_step, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<Timestamp> {
        Ok(Timestamp {
            start_digest: <std::vec::Vec<u8> as uniffi::FfiConverter>::try_read(buf)?,
            first_step: <FfiConverterTypeStep as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

#[doc(hidden)]
pub struct FfiConverterTypeDetachedTimestampFile;

#[doc(hidden)]
impl uniffi::RustBufferFfiConverter for FfiConverterTypeDetachedTimestampFile {
    type RustType = DetachedTimestampFile;

    fn write(obj: DetachedTimestampFile, buf: &mut std::vec::Vec<u8>) {
        // If the provided struct doesn't match the fields declared in the UDL, then
        // the generated code here will fail to compile with somewhat helpful error.
        <FfiConverterTypeDigestType as uniffi::FfiConverter>::write(obj.digest_type, buf);
        <FfiConverterTypeTimestamp as uniffi::FfiConverter>::write(obj.timestamp, buf);
    }

    fn try_read(buf: &mut &[u8]) -> uniffi::deps::anyhow::Result<DetachedTimestampFile> {
        Ok(DetachedTimestampFile {
            digest_type: <FfiConverterTypeDigestType as uniffi::FfiConverter>::try_read(buf)?,
            timestamp: <FfiConverterTypeTimestamp as uniffi::FfiConverter>::try_read(buf)?,
        })
    }
}

// Top level functions, corresponding to UDL `namespace` functions.// Object definitions, corresponding to UDL `interface` definitions.

// Callback Interface definitions, corresponding to UDL `callback interface` definitions.

// External and Wrapped types
// Support for external types.

// Types with an external `FfiConverter`...

// For custom scaffolding types we need to generate an FfiConverterType based on the
// UniffiCustomTypeConverter implementation that the library supplies
